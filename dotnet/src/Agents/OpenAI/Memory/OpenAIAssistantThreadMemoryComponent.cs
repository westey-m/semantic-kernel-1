// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Agents.Memory;
using Microsoft.SemanticKernel.Agents.OpenAI.Internal;
using OpenAI.Assistants;

namespace Microsoft.SemanticKernel.Agents.OpenAI;

public class OpenAIAssistantThreadMemoryComponent : ThreadManagementMemoryComponent
{
    private bool _threadActive = false;
    private string _threadId = string.Empty;
    private readonly AssistantClient _client;

    public OpenAIAssistantThreadMemoryComponent(AssistantClient client)
    {
        this._client = client;
    }

    public string ThreadId => this._threadId;

    public override bool HasActiveThread => this._threadActive;

    public override async Task<string> StartNewThreadAsync(CancellationToken cancellationToken = default)
    {
        if (this._threadActive)
        {
            throw new InvalidOperationException("Thread already active.");
        }

        var assitantThreadResponse = await this._client.CreateThreadAsync(cancellationToken: cancellationToken).ConfigureAwait(false);
        this._threadId = assitantThreadResponse.Value.Id;
        this._threadActive = true;

        return assitantThreadResponse.Value.Id;
    }

    public override async Task EndThreadAsync(CancellationToken cancellationToken = default)
    {
        if (!this._threadActive)
        {
            throw new InvalidOperationException("No thread active.");
        }

        await this._client.DeleteThreadAsync(this._threadId, cancellationToken).ConfigureAwait(false);
    }

    public override async Task LoadContextAsync(string? inputText = null, CancellationToken cancellationToken = default)
    {
    }

    public override async Task MaintainContextAsync(ChatMessageContent newMessage, CancellationToken cancellationToken = default)
    {
        if (!this._threadActive)
        {
            throw new InvalidOperationException("No thread active.");
        }

        // If the message was generated by this agent, it is already in the thread and we shouldn't add it again.
        if (newMessage.Metadata == null || !newMessage.Metadata.TryGetValue("ThreadId", out var messageThreadId) || !string.Equals(messageThreadId, this._threadId))
        {
            await AssistantThreadActions.CreateMessageAsync(this._client, this._threadId, newMessage, cancellationToken).ConfigureAwait(false);
        }
    }

    public override async Task SaveContextAsync(CancellationToken cancellationToken = default)
    {
    }

    public override Task<string> GetFormattedContextAsync(CancellationToken cancellationToken = default)
    {
        return Task.FromResult(string.Empty);
    }
}
